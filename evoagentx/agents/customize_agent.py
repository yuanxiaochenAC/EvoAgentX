import json
from pydantic import create_model, Field
from typing import Union, Optional, List

from .agent import Agent
from ..models.base_model import BaseLLM
from ..prompts.utils import DEFAULT_SYSTEM_PROMPT
from ..actions.action import Action, ActionInput, ActionOutput
from ..utils.utils import generate_dynamic_class_name

@classmethod
def customize_get_content_data(cls, content: str, **kwargs) -> dict:
    """
    parse the LLM generated data to a dict, only valid when the data of all attrs is continuous in the `content`.
    """
    attrs = cls.get_attrs()
    if not attrs:
        return {}
    output_titles = [f"## {attr}" for attr in attrs]

    def is_output_title(text: str):
        return any(text.strip().startswith(title) for title in output_titles)

    data = {}
    current_output_name: str = None
    current_output_content: list = None
    for line in content.split("\n"):
        if is_output_title(line):
            if current_output_name is not None and current_output_content is not None:
                data[current_output_name] = "\n".join(current_output_content)
            current_output_content = []
            current_output_name = line.replace("#", "").strip()
        else: 
            if current_output_content is not None:
                current_output_content.append(line)
    if current_output_name is not None and current_output_content is not None:
        data[current_output_name] = "\n".join(current_output_content)
    return data


def customize_to_str(self) -> str:
    
    data: dict = self.get_structured_data()
    outputs = [] 
    for key, value in data.items():
        outputs.append("### {}\n{}".format(key, value))
    return "\n\n".join(outputs)


def customize_action_execute(self, llm: Optional[BaseLLM] = None, inputs: Optional[dict] = None, sys_msg: Optional[str]=None, return_prompt: bool = False, **kwargs) -> ActionOutput:

    prompt_params_names = self.inputs_format.get_attrs()
    # prompt_params_values = {param: inputs.get(param, "") for param in prompt_params_names}
    prompt_params_values = {}
    for param in prompt_params_names:
        value = inputs.get(param, "")
        if isinstance(value, str):
            prompt_params_values[param] = value
        elif isinstance(value, (dict, list)):
            prompt_params_values[param] = json.dumps(value, indent=4)
        else:
            raise TypeError(f"The input type {type(value)} to `customize_action_execute` is invalid!")
    prompt = self.prompt.format(**prompt_params_values)
    output = llm.generate(prompt=prompt, system_message=sys_msg, parser=self.outputs_format)

    if return_prompt:
        return output, prompt
    
    return output


class CustomizeAgent(Agent):
    """
    A class to initialize an Agent specified by the user or generated by an LLM. Input format:
    {
        "name": str, 
        "description": str, 
        "prompt": str, 
        "llm_config": dict,
        "inputs": [
            {name: str, type: str, description: str}, 
        ],
        "outputs": [
            {name: str, type: str, description: str}
        ]
    }
    """
    def __init__(self, **kwargs):
        
        name = kwargs["name"]
        description = kwargs["description"]
        prompt = kwargs.pop("prompt", None)
        inputs = kwargs.pop("inputs", [])
        outputs = kwargs.pop("outputs", [])
        system_prompt = kwargs.pop("system_prompt") if "system_prompt" in kwargs else DEFAULT_SYSTEM_PROMPT
        customize_action = self.create_customize_action(
            name=name, desc=description, prompt=prompt, inputs=inputs, outputs=outputs
        )
        super().__init__(system_prompt=system_prompt, actions=[customize_action], **kwargs)

    @property
    def customize_action_name(self):
        return self.name
    
    def create_customize_action(self, name: str, desc: str, prompt: str, inputs: List[dict], outputs: List[dict]) -> Action:

        assert prompt is not None, "must provide `prompt` when creating CustomizeAgent"

        action_input_fields = {}
        for field in inputs:
            action_input_fields[field["name"]] = (str, Field(description=field["description"]))
        action_input_type = create_model(
            generate_dynamic_class_name(name+" ActionInput"),
            **action_input_fields, 
            __base__=ActionInput
        )
        action_output_fields = {}
        for field in outputs:
            action_output_fields[field["name"]] = (Union[str, dict, list], Field(description=field["description"]))
        action_output_type = create_model(
            generate_dynamic_class_name(name+" ActionOutput"),
            **action_output_fields, 
            __base__=ActionOutput,
            get_content_data=customize_get_content_data,
            to_str=customize_to_str
        )

        customize_action_cls = create_model(
            generate_dynamic_class_name(name+" Action"),
            __base__=Action, 
            execute=customize_action_execute
        )
        customize_action = customize_action_cls(
            name = generate_dynamic_class_name(name+" Action"),
            description=desc, 
            prompt=prompt, 
            inputs_format=action_input_type, 
            outputs_format=action_output_type
        )
        return customize_action